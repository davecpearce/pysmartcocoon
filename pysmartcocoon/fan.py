"""Define a SmartCocoon Fan class."""

import logging
from datetime import datetime
from typing import Any, Optional

from pysmartcocoon.api import SmartCocoonAPI
from pysmartcocoon.const import FanMode
from pysmartcocoon.fan_helpers import derive_mode_from_speed, resolve_speed

_LOGGER: logging.Logger = logging.getLogger(__name__)


# pylint: disable=too-many-instance-attributes, too-many-public-methods
class Fan:
    """Define the fan."""

    def __init__(
        self,
        fan_id: str,
        api: SmartCocoonAPI,
    ) -> None:
        """Initialize."""

        # Fan attributes from SmartCocoon
        self._fan_id: str = fan_id
        self._identifier: Optional[int] = None
        self._fan_on: Optional[bool] = None
        self._firmware_version: Optional[str] = None
        self._is_room_estimating: Optional[bool] = None
        self._connected: Optional[bool] = None
        self._last_connection: Optional[datetime] = None
        self._mode: Optional[str] = None
        self._power: Optional[int] = None
        self._predicted_room_temperature: Optional[float] = None
        self._room_id: Optional[int] = None
        self._thermostat_vendor: Optional[int] = None
        self._mqtt_username: Optional[str] = None
        self._mqtt_password: Optional[str] = None

        # Extra attributes not provided by API
        self._room_name: str = None

        self._api = api

    @property
    def identifier(self) -> Optional[int]:  # pylint: disable=invalid-name
        """Return Fan id.

        This is a numerical ID generated by SmartCocoon
        This value can change if the fan is re-added to
        an cloud account
        """
        return self._identifier

    @property
    def fan_id(self) -> str:
        """Return Fan fan_id.

        This is the physical ID printed on the fan
        """
        return self._fan_id

    @property
    def fan_on(self) -> Optional[bool]:
        """Return a bool indicating if the fan is on or off
        On = True
        Off = False
        """
        return self._fan_on

    @property
    def firmware_version(self) -> Optional[str]:
        """Return the firmware version of the fan"""
        return self._firmware_version

    @property
    def is_room_estimating(self) -> Optional[bool]:
        """Return value to indicate if the room is estimating temp
        Estimating = True
        Not Estimating = False
        """
        return self._is_room_estimating

    @property
    def connected(self) -> Optional[bool]:
        """Return a bool indicating if the fan is connected
        Connected = True
        Not Connected = False
        """
        return self._connected

    @property
    def last_connection(self) -> Optional[datetime]:
        """Return a bool indicating if the fan is connected
        Connected = True
        Not Connected = False
        """
        return self._last_connection

    @property
    def mode(self) -> Optional[str]:
        """Return the current mode setting of the fan"""
        return self._mode

    @property
    def mode_enum(self) -> FanMode:
        """Return the current mode setting of the fan"""
        return FanMode(self._mode) if self._mode is not None else FanMode.OFF

    @property
    def power(self) -> int:
        """Return the current power setting of the fan
        % value is multiplied by 100
        100% = power level of 10000
        """
        return self._power or 0

    @property
    def speed_pct(self) -> int:
        """Return the current power setting of the fan
        by %
        """
        return int(self._power / 100) if self._power is not None else 0

    @property
    def predicted_room_temperature(self) -> Optional[float]:
        """Return the predicted room temperature of the fan"""
        return self._predicted_room_temperature

    @property
    def room_name(self) -> Optional[str]:
        """Return the room name of the fan"""
        return self._room_name

    @property
    def room_id(self) -> Optional[int]:
        """Return the room id of the fan"""
        return self._room_id

    @property
    def thermostat_vendor(self) -> Optional[int]:
        """Return the thermostat vendor of the fan"""
        return self._thermostat_vendor

    @property
    def mqtt_username(self) -> Optional[str]:
        """Return the MQTT username of the fan"""
        return self._mqtt_username

    @property
    def mqtt_password(self) -> Optional[str]:
        """Return the MQTT password of the fan"""
        return self._mqtt_password

    def set_speed_pct(self, fan_speed_pct: int) -> bool:
        """Update the power of the fan"""

        if fan_speed_pct > 100:
            _LOGGER.debug(
                (
                    "Fan ID: %s - Fan speed of %s%% is invalid, must be "
                    "between 0%% and 100%%"
                ),
                self.fan_id,
                str(fan_speed_pct),
            )

        _LOGGER.debug(
            "Fan ID: %s - Updating fan speed to %s%%",
            self.fan_id,
            str(fan_speed_pct),
        )

        self._power = fan_speed_pct * 100
        return True

    def set_room_name(self, room_name: str) -> bool:
        """Update the room_name"""

        _LOGGER.debug(
            "Fan ID: %s - Updating room_name to '%s'", self.fan_id, room_name
        )

        self._room_name = room_name
        return True

    # pylint: disable=too-many-branches
    async def async_set_fan_modes(
        self,
        fan_mode: Optional[FanMode] = None,
        fan_speed_pct: Optional[int] = None,
    ) -> bool:
        """Set the fan mode and speed."""

        _LOGGER.debug(
            (
                "Fan ID: %s - In async_set_fan_mode with fan_mode: %s and"
                " fan_speed: %s%%"
            ),
            self.fan_id,
            fan_mode,
            str(fan_speed_pct),
        )

        if fan_mode is None and fan_speed_pct is None:
            _LOGGER.debug(
                "async_set_fan_modes must provide a value for fan_mode and/or"
                " fan_speed"
            )
            return False

        if fan_mode is None:
            fan_mode = derive_mode_from_speed(self.mode_enum, fan_speed_pct)

        # Update fan mode if changed
        if self.mode_enum != fan_mode:
            self._mode = fan_mode.value

        fan_speed_pct = resolve_speed(self.speed_pct, fan_mode, fan_speed_pct)
        if fan_speed_pct is None:
            return False

        # Update power if changed
        if self.speed_pct != fan_speed_pct:
            self.set_speed_pct(fan_speed_pct)

        await self._async_set_fan(fan_mode)
        return True

    # helpers moved to fan_helpers.py

    async def _async_set_fan(self, fan_mode: Optional[FanMode] = None) -> bool:
        """Call the API to update the fan mode and speed."""

        await self._api.async_update_fan(
            fan_identifier=self._identifier, mode=self.mode, power=self.power
        )

        _LOGGER.debug(
            "Fan ID: %s - Fan Mode was set to %s, speed to %s",
            self.fan_id,
            self.mode,
            self.speed_pct,
        )

        await self._async_update_fan()

        if fan_mode == FanMode.ON and not self.fan_on:
            _LOGGER.debug(
                "Fan ID: %s - Changing fan_on to 'True'", self.fan_id
            )
            self._fan_on = True
        elif fan_mode == FanMode.OFF:
            _LOGGER.debug(
                "Fan ID: %s - Changing fan_on to 'False'", self.fan_id
            )
            self._fan_on = False

    async def async_update_api_data(
        self,
        data: dict[str, Any],
    ) -> bool:
        """Selectively update the fan attributes with API data"""

        _LOGGER.debug("Fan ID: %s - In async_update_api_data", data["fan_id"])

        self._identifier: int = data["id"]
        self._fan_id: str = (
            data["fan_id"] if data.get("fan_id") is not None else self._fan_id
        )

        # Fan attributes from SmartCocoon
        self._mode: str = data["mode"]

        # fan_on does not always reflect the current mode, mode is more
        # accurate if set to always_on or always_off

        if self._mode == FanMode.ON.value:
            self._fan_on = True
        elif self._mode == FanMode.OFF.value:
            self._fan_on = False
        else:
            self._fan_on: bool = data["fan_on"]

        self._firmware_version = data["firmware_version"]
        self._is_room_estimating = data["is_room_estimating"]
        self._connected = data["connected"]
        # Parse last_connection to datetime when provided as string
        last_conn = data["last_connection"]
        if isinstance(last_conn, str):
            try:
                iso_str = last_conn.replace("Z", "+00:00")
                self._last_connection = datetime.fromisoformat(iso_str)
            except Exception:  # pylint: disable=broad-except
                _LOGGER.debug(
                    "Fan ID: %s - Unable to parse last_connection: %s",
                    self.fan_id,
                    last_conn,
                )
                self._last_connection = None
        else:
            self._last_connection = last_conn
        self._power = data["power"]
        self._predicted_room_temperature = data["predicted_room_temperature"]
        self._room_id = data["room_id"]
        self._thermostat_vendor = data["thermostat_vendor"]
        self._mqtt_username = data["mqtt_username"]
        self._mqtt_password = data["mqtt_password"]

    async def _async_update_fan(self) -> bool:
        _LOGGER.debug(
            "Fan ID: %s - Updating fan attributes from cloud", self.fan_id
        )

        response = await self._api.async_get_fan(self._identifier)

        if response is not None:
            await self.async_update_api_data(response)

        return True
